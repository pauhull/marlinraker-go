package files

import (
	"bufio"
	buf "bytes"
	"encoding/base64"
	"errors"
	"fmt"
	"image"
	"image/draw"
	"image/png"
	"io"
	"math"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

	"github.com/nfnt/resize"
	"github.com/samber/lo"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/afero"
)

type imageData struct {
	width  int
	height int
	bytes  []byte
}

var thumbnailBeginRegex = regexp.MustCompile(`thumbnail begin ([0-9]+)x([0-9]+)`)

func ScanMetadata(fileName string) (*Metadata, error) {

	diskPath := filepath.Join(DataDir, "gcodes", fileName)

	file, err := Fs.Open(diskPath)
	if err != nil {
		return nil, fmt.Errorf("failed to open file %q: %w", diskPath, err)
	}

	defer func() {
		if err := file.Close(); err != nil {
			log.Errorf("Failed to close file %q: %v", diskPath, err)
		}
	}()

	stat, err := file.Stat()
	if err != nil {
		return nil, fmt.Errorf("failed to stat file %q: %w", diskPath, err)
	}

	metadata := &Metadata{
		FileName: fileName,
		Size:     stat.Size(),
		Modified: float64(stat.ModTime().UnixMilli()) / 1000.0,
	}

	thumbnailData := make([]imageData, 0)
	reader := bufio.NewReader(file)
	var position int64
	for {
		startPos := position
		bytes, err := reader.ReadBytes('\n')
		if err != nil {
			if !errors.Is(err, io.EOF) {
				return nil, fmt.Errorf("failed to read data: %w", err)
			}
			break
		}
		position += int64(len(bytes))
		line := strings.TrimSpace(string(bytes))

		if line == "" {
			continue
		}
		if !strings.HasPrefix(line, ";") {
			metadata.GcodeStartByte = startPos
			break
		}

		line = strings.TrimSpace(line[1:])
		if line == "" {
			continue
		}

		switch {
		case strings.HasPrefix(line, "generated by") || strings.HasPrefix(line, "Generated with"):
			parts := strings.Split(line, " ")
			if len(parts) >= 3 {
				metadata.Slicer = parts[2]
			}
			if len(parts) >= 4 {
				metadata.SlicerVersion = parts[3]
			}

		case strings.HasPrefix(line, "thumbnail begin"):
			read, data, err := extractThumbnail(line, reader)
			if err != nil {
				return nil, err
			}
			position += read
			thumbnailData = append(thumbnailData, data)

		case strings.ContainsRune(line, ':'):
			parts := strings.Split(line, ":")
			key, value := strings.TrimSpace(parts[0]), strings.TrimSpace(parts[1])

			switch key {
			case "TIME":
				time, err := strconv.ParseFloat(value, 64)
				if err == nil {
					metadata.EstimatedTime = time
				}

			case "MAXZ":
				height, err := strconv.ParseFloat(value, 64)
				if err == nil {
					metadata.ObjectHeight = height
				}

			case "Filament used":
				used, err := strconv.ParseFloat(value[:len(value)-1], 64)
				if err == nil {
					metadata.FilamentTotal = used * 1000.0
				}

			case "Layer height":
				height, err := strconv.ParseFloat(value, 64)
				if err == nil {
					metadata.LayerHeight = height
				}
			}
		}
	}

	toDiscard := stat.Size() - position - 50000
	if toDiscard > 0 {
		discarded, err := reader.Discard(int(toDiscard))
		if err != nil {
			return nil, fmt.Errorf("failed to discard data: %w", err)
		}
		position += int64(discarded)
	}

	for {
		bytes, err := reader.ReadBytes('\n')
		if err != nil {
			if !errors.Is(err, io.EOF) {
				return nil, fmt.Errorf("failed to read data: %w", err)
			}
			break
		}
		position += int64(len(bytes))
		line := strings.TrimSpace(string(bytes))

		if line == "" {
			continue
		}

		if !strings.HasPrefix(line, ";") {
			metadata.GcodeEndByte = position
			continue
		}

		line = strings.TrimSpace(line[1:])
		switch {
		case strings.HasPrefix(line, "Z:"):
			z, err := strconv.ParseFloat(line[2:], 64)
			if err == nil {
				metadata.ObjectHeight = math.Max(metadata.ObjectHeight, z)
			}

		case strings.ContainsRune(line, '='):
			parts := strings.Split(line, "=")
			key, value := strings.TrimSpace(parts[0]), strings.TrimSpace(parts[1])

			switch key {
			case "layer_height":
				height, err := strconv.ParseFloat(value, 64)
				if err == nil {
					metadata.LayerHeight = height
				}

			case "first_layer_height":
				height, err := strconv.ParseFloat(value, 64)
				if err == nil {
					metadata.FirstLayerHeight = height
				}

			case "filament used [mm]":
				used, err := strconv.ParseFloat(value, 64)
				if err == nil {
					metadata.FilamentTotal = used
				}

			case "filament used [g]":
				used, err := strconv.ParseFloat(value, 64)
				if err == nil {
					metadata.FilamentWeightTotal = used
				}

			case "first_layer_bed_temperature":
				temp, err := strconv.ParseFloat(value, 64)
				if err == nil {
					metadata.FirstLayerBedTemp = temp
				}

			case "first_layer_temperature":
				temp, err := strconv.ParseFloat(value, 64)
				if err == nil {
					metadata.FirstLayerExtrTemp = temp
				}

			case "nozzle_diameter":
				diameter, err := strconv.ParseFloat(value, 64)
				if err == nil {
					metadata.NozzleDiameter = diameter
				}

			case "filament_settings_id":
				metadata.FilamentName = value

			case "filament_type":
				metadata.FilamentType = value

			case "estimated printing time (normal mode)":
				time := 0
				for _, s := range strings.Split(value, " ") {
					t, err := strconv.ParseInt(s[:len(s)-1], 10, 32)
					if err != nil {
						continue
					}
					switch s[len(s)-1] {
					case 's':
						time += int(t)
					case 'm':
						time += int(t) * 60
					case 'h':
						time += int(t) * 60 * 60
					case 'd':
						time += int(t) * 24 * 60 * 60
					}
				}
				metadata.EstimatedTime = float64(time)
			}
		}
	}

	if len(thumbnailData) > 0 {
		var has32, has300 bool
		for _, data := range thumbnailData {
			if data.width == 32 && data.height == 32 {
				has32 = true
			} else if data.width == 300 && data.height == 300 {
				has300 = true
			}
		}

		if !has32 || !has300 {
			var largest *imageData
			largestArea := 0
			for _, data := range thumbnailData {
				area := data.width * data.height
				if largest == nil || largestArea < area {
					largest = &data
					largestArea = area
				}
			}

			if !has32 {
				bytes, err := resizeImage(largest.bytes, 32)
				if err != nil {
					return nil, err
				}
				thumbnailData = append(thumbnailData, imageData{32, 32, bytes})
			}
			if !has300 {
				bytes, err := resizeImage(largest.bytes, 300)
				if err != nil {
					return nil, err
				}
				thumbnailData = append(thumbnailData, imageData{300, 300, bytes})
			}
		}
	}

	dir := filepath.Dir(fileName)
	baseName := filepath.Base(fileName)
	if idx := strings.Index(baseName, "."); idx != -1 {
		baseName = baseName[:idx]
	}

	metadata.Thumbnails = make([]Thumbnail, 0)
	for _, data := range thumbnailData {
		relPath := fmt.Sprintf(".thumbs/%s-%dx%d.png", baseName, data.width, data.height)
		diskPath := filepath.Join(DataDir, "gcodes", dir, relPath)
		if err := Fs.MkdirAll(filepath.Dir(diskPath), 0755); err != nil {
			log.Errorf("Failed to create directory %q: %v", filepath.Dir(diskPath), err)
			break
		}
		if err := afero.WriteFile(Fs, diskPath, data.bytes, 0755); err != nil {
			log.Errorf("Failed to write thumbnail %q: %v", diskPath, err)
		}
		metadata.Thumbnails = append(metadata.Thumbnails, Thumbnail{
			Size:         len(data.bytes),
			Width:        data.width,
			Height:       data.height,
			RelativePath: relPath,
		})
	}

	return metadata, nil
}

func extractThumbnail(header string, reader *bufio.Reader) (int64, imageData, error) {

	var width, height int
	if match := thumbnailBeginRegex.FindStringSubmatch(header); match != nil {
		width = int(lo.Must(strconv.ParseInt(match[1], 10, 32)))
		height = int(lo.Must(strconv.ParseInt(match[2], 10, 32)))
	} else {
		return 0, imageData{}, nil
	}

	var (
		read    int64
		builder strings.Builder
	)
	for {
		bytes, err := reader.ReadBytes('\n')
		if err != nil {
			return read, imageData{}, fmt.Errorf("failed to read thumbnail: %w", err)
		}
		read += int64(len(bytes))

		line := strings.TrimSpace(string(bytes))
		if !strings.HasPrefix(line, ";") {
			return read, imageData{}, nil
		}

		line = strings.TrimSpace(line[1:])
		if line == "thumbnail end" {
			break
		}
		builder.WriteString(line)
	}

	data, err := base64.StdEncoding.DecodeString(builder.String())
	if err != nil {
		log.Errorf("Failed to decode thumbnail: %v", err)
		return read, imageData{}, nil
	}
	return read, imageData{width, height, data}, nil
}

func resizeImage(data []byte, size int) ([]byte, error) {

	inputImage, err := png.Decode(buf.NewReader(data))
	if err != nil {
		return nil, fmt.Errorf("failed to decode image: %w", err)
	}

	width := inputImage.Bounds().Size().X
	height := inputImage.Bounds().Size().Y
	var newWidth, newHeight int
	if width > height {
		newWidth = size * width / height
		newHeight = size
	} else {
		newWidth = size
		newHeight = size * height / width
	}

	if newWidth < 1 || newHeight < 1 || newWidth > math.MaxInt32 || newHeight > math.MaxInt32 {
		return nil, errors.New("invalid image size")
	}
	resizedImage := resize.Resize(uint(newWidth), uint(newHeight), inputImage, resize.Bilinear)

	finalImage := image.NewRGBA(image.Rect(0, 0, size, size))
	offsetX := (size - newWidth) / 2
	offsetY := (size - newHeight) / 2
	draw.Draw(finalImage, image.Rect(offsetX, offsetY, offsetX+newWidth, offsetY+newHeight), resizedImage, image.Point{}, draw.Over)

	var buffer buf.Buffer
	err = png.Encode(&buffer, finalImage)
	if err != nil {
		return nil, fmt.Errorf("failed to encode image: %w", err)
	}
	return buffer.Bytes(), nil
}
